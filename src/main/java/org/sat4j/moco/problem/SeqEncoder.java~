/*******************************************************************************
 * SAT4J: a SATisfiability library for Java Copyright (C) 2004, 2012 Artois University and CNRS
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 *  http://www.eclipse.org/legal/epl-v10.html
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU Lesser General Public License Version 2.1 or later (the
 * "LGPL"), in which case the provisions of the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of the LGPL, and not to allow others to use your version of
 * this file under the terms of the EPL, indicate your decision by deleting
 * the provisions above and replace them with the notice and other provisions
 * required by the LGPL. If you do not delete the provisions above, a recipient
 * may use your version of this file under the terms of the EPL or the LGPL.
 *
 * Contributors:
 *   CRIL - initial API and implementation
 *   Jo√£o O'Neill Cortes, INESC
 *******************************************************************************/
package org.sat4j.moco.problem;

import java.math.BigInteger;

import org.sat4j.core.ReadOnlyVec;
import org.sat4j.core.ReadOnlyVecInt;
import org.sat4j.core.Vec;
import org.sat4j.core.VecInt;
import org.sat4j.moco.util.Real;
import org.sat4j.moco.pb.PBFactory;
import org.sat4j.pb.IPBSolver;
import org.sat4j.moco.pb.PBSolver;
import org.sat4j.moco.pb.ConstrID;
import org.sat4j.specs.ContradictionException;
import org.sat4j.specs.IConstr;
import org.sat4j.specs.IVec;
import org.sat4j.specs.IVecInt;

/**
 * Class with the implementation of the sequetial encoder. 
 * @author Miguel Terra-Neves
 */

 public class SeqEncoder {

     /** 
      * IDs of the variables used to enforce the semantics of the sequential encoder
      */
     private Instance instance = null;
     private int[][][] ids = null;
     private ConstrID topConstraint = null;
     private PBSolver solver = null;
     private int[] currentKs = null;
    /**
     * Creates an Instance of the sequential encoder
     * @param lits The literals in the constraint's left-hand side.
     * @param coeffs The coefficients in the constraint's left-hand side.
     * @param rhs The constraint's right-hand side.
     */

     public SeqEncoder(Instance instance, PBSolver solver) {
	this.instance = instance;	
	this.solver = solver;
	this.initializeIDs();
	this.currentKs = new int[this.instance.nObjs()];
	
    }


     private void initializeIDs(){
	this.ids = new int[this.instance.nObjs()][][];
	for(int i = 0;i< instance.nObjs(); ++i){
	    Objective ithObj = instance.getObj(i);
	    this.ids[i] = new int[ithObj.getTotalLits()][];
	    for(int k = 0; k < ithObj.getTotalLits();++k)
		this.ids[i][k] = new int[ithObj.getTotalWeight()];
	}
     }

     public int get(int iObj, int iX, int iK){
	 return	 this.ids[iObj][iX][iK];
     }

     public void set(int iObj, int iX, int iK, int id){
	 this.ids[iObj][iX][iK] = id;

     }
    /**
     *My little method. It should add the hard constraints needed for
     *the sequential encoding. I need to add the variables before I can 
     *@param iObj The objective index
     *@param kBefore The previous max value for the objective
     *@param kNow The desired max value for the objective 
     */

    
    public void SequentialEncoderAddClauses(int iObj , int afterK ){

	assert this.currentKs[iObj] < afterK;

	int nLit = this.instance.getObj(iObj).getTotalLits();
	for (int iX = 1 ; iX < nLit-1; ++iX){
	    for (int k  = this.currentKs[iObj];  k < afterK; ++k){
		this.IfLessAlsoMore(iObj, iX, k);
		
	    }
	}
    }

     private void IfLessAlsoMore(int iObj, int iX, int k){

     }




     public void ExtendTopIdsInK(int iObj, int afterK){
	 this.solver.newVars(1);
	 int nLit = this.instance.getObj(iObj).getTotalLits();
	 for (int iX = 0 ; iX < nLit-1; ++iX){
	     for(int k = this.currentKs[iObj]; k < afterK; ++k){
	     this.solver.newVars(1);
	     this.set(iObj, iX, k, this.solver.nVars());	     
	     }
	 }
	 
     }
    

}
